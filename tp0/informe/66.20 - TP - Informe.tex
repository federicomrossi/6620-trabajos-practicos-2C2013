\documentclass{article}

%% PAQUETES

% Paquetes generales
\usepackage[margin=2cm, paperwidth=210mm, paperheight=297mm]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{gensymb}

% Paquetes para estilos
\usepackage{textcomp}
\usepackage{setspace}
\usepackage{colortbl}
\usepackage{color}
\usepackage{color}
\usepackage{upquote}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}

% Paquetes extras
\usepackage{amssymb}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\usepackage[toc,page]{appendix}
\usepackage{mips}


%% Fin PAQUETES


% Definición de preferencias para la impresión de código fuente.
%% Colores
\definecolor{gray99}{gray}{.99}
\definecolor{gray95}{gray}{.95}
\definecolor{gray75}{gray}{.75}
\definecolor{gray50}{gray}{.50}
\definecolor{keywords_blue}{rgb}{0.13,0.13,1}
\definecolor{comments_green}{rgb}{0,0.5,0}
\definecolor{strings_red}{rgb}{0.9,0,0}

%% Caja de código
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFont{style_labelfont}{\color{black}\textbf}
\DeclareCaptionFont{style_textfont}{\it\color{black}}
\DeclareCaptionFormat{listing}{\colorbox{gray95}{\parbox{16.78cm}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=style_labelfont,textfont=style_textfont}

\lstset{
	aboveskip = {1.5\baselineskip},
	backgroundcolor = \color{gray99},
	basicstyle = \ttfamily\footnotesize,
	breakatwhitespace = true,   
	breaklines = true,
	captionpos = t,
	columns = fixed,
	commentstyle = \color{comments_green},
	escapeinside = {\%*}{*)}, 
	extendedchars = true,
	frame = lines,
	keywordstyle = \color{keywords_blue}\bfseries,
	language = C,                       
	numbers = left,
	numbersep = 5pt,
	numberstyle = \tiny\ttfamily\color{gray50},
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	rulecolor = \color{gray75},
	showspaces = false,
	showstringspaces = false, 
	showtabs = false,
	stepnumber = 1,
	stringstyle = \color{strings_red},                                    
	tabsize = 2,
	title = \null, % Default value: title=\lstname
	upquote = true,                  
}

%% FIGURAS
\captionsetup[figure]{labelfont=bf,textfont=it}
%% TABLAS
\captionsetup[table]{labelfont=bf,textfont=it}

% COMANDOS

%% Titulo de las cajas de código
\renewcommand{\lstlistingname}{Código}
%% Titulo de las figuras
\renewcommand{\figurename}{Figura}
%% Titulo de las tablas
\renewcommand{\tablename}{Tabla}
%% Referencia a los códigos
\newcommand{\refcode}[1]{\textit{Código \ref{#1}}}
%% Referencia a las imagenes
\newcommand{\refimage}[1]{\textit{Imagen \ref{#1}}}

%% APENDICES
\addto\captionsspanish{
	\renewcommand\seename{Apéndices}
	\renewcommand\appendixname{Apéndices}
	\renewcommand\appendixpagename{Apéndices}
}


\begin{document}
\pagenumbering{roman}
\setcounter{page}{5}

% TÍTULO, AUTORES Y FECHA
\begin{titlepage}
	\vspace*{\fill}
	\begin{center}
		\huge{Trabajo Pŕactico N°0} \\
		\medskip
		\Huge \textit{``Infraestructura básica''} \\
		
		\bigskip\bigskip\bigskip\bigskip\bigskip

		\Large Belén Beltran, Padrón Nro. 91.718 \\
		\large \textit{belubeltran@gmail.com} \\ \medskip
		\Large Pablo Ariel Rodriguez, Padrón Nro. 93.970 \\
		\large \textit{prodriguez@fi.uba.ar} \\ \medskip
		\Large Federico Martín Rossi, Padrón Nro. 92.086 \\
		\large \textit{federicomrossi@gmail.com} \\

		\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip\bigskip

		\large 2do. Cuatrimestre 2013 \\ \smallskip
		\large 66.20 Organización de Computadoras \\ \smallskip
		\large Facultad de Ingeniería, Universidad de Buenos Aires \\ \smallskip

		\date{}
	\end{center}
	\vspace*{\fill}
\end{titlepage}

\newpage
\newpage \textit{}
\newpage



% ÍNDICE
\tableofcontents
\newpage \textit{}
\newpage
\pagenumbering{arabic}




% Introducción
\section{Introducción}
	
	En el presente trabajo se tiene como objetivo la familiarización con las herramientas de software que se utilizarán a lo largo de los siguientes trabajos prácticos, llevando a cabo la implementación de un programa que resuelve cierta problemática piloto detallada en los próximos apartados.
	\par
	La implementación se realizará en el lenguaje de programación C. Luego se ejecutará la aplicación sobre una plataforma \textit{NetBSD/MIPS-32} mediante el emulador \textit{GXEmul} \cite{GXEMUL}. Finalmente generaremos, mediante el compilador \textit{GCC} \cite{GCC}, el equivalente en assembler MIPS del código fuente en C.
	\par
	Todos los archivos y códigos fuente aquí mencionados, así como también el presente informe, pueden ser descargados como un archivo comprimido ZIP del repositorio del grupo\footnote{URI del Repositorio: \url{https://github.com/federicomrossi/6620-trabajos-practicos-2C2013/tree/master/tp0}}.
\bigskip




% Compilación
\section{Compilación}
	
	La herramienta para compilar el código en lenguaje C será el \textit{GCC}.
	\par
	Para automatizar las tareas de compilación se hace uso de la herramienta \textit{GNU Make}. Los Makefiles utilizados para la compilación se incluyen junto al resto de los archivos fuentes del presente trabajo.
\bigskip




% Utilización
\section{Utilización}
	
	En los siguientes apartados se especifica la forma en la que debe ser ejecutado el programa implementado en lenguaje C. El resultado de la compilación con ``make'' será un programa ejecutable, de nombre \textit{tp0}, que podrá ser invocado con los siguientes parámetros:
\medskip

\begin{itemize}

\itemsep=2pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item \textit{-h}:  Imprime ayuda para la utilización del programa;
	\item \textit{-V}:  Imprimer la versión actual del programa;
	\item \textit{-r [Width]x[Height]}: Setea la resolución en píxeles del bitmap;
	\item \textit{-o [Path]}: Especifica la ruta del archivo de salida sobre el cual se guarda el tablero generado por la aplicación.

\end{itemize}
\medskip




% Implementación
\section{Implementación}
	
	En lo que sigue de la sección, se presentarán los códigos fuente de la implementación del algoritmo. Aquellos lectores interesados en la implementación completa del programa, pueden dirigirse al apéndic ubicado al final del presente informe.



\subsection{Implementación en C}

	La implementación del programa fue divida en los siguientes módulos:
	\medskip

\begin{itemize}

\itemsep=2pt \topsep=0pt \partopsep=0pt \parskip=0pt \parsep=0pt
	\item \textbf{tp0}: Programa principal responsable de interpretar los parámetros especificados a través de la terminal de modo de que realice las tareas solicitadas por el usuario. Su función es, de acuerdo al parámetro o los parámetros especificados, llevar a cabo la ejecución solicitada haciendo uso de módulos externos;
	\item \textbf{pgm}: Módulo encargado de generar una imagen de un tablero de ajedrez (cuadrado, de ocho casilleros de lado) conforme a los parámetros ingresados. Se utiliza para ello el formato gráfico PGM o \textit{portable gray map}. De especificarse un archivo de salida, la imagen en formato PGM se almacenará en este medio.

\end{itemize}	
\medskip


% Algoritmo PGM
\subsubsection{Algoritmo \textit{Pgm}}

	En el \refcode{codeBSh} se muestra el header de la librería, donde se declara la función Bubblesort, mientras que en el \refcode{codeBSc} se muestra la definición de la librería.

% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeBSh,caption=``bubblesort.h'']{../Codigo/c/bubblesort.h} 
% \bigskip


% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeBSc,caption=``bubblesort.c'']{../Codigo/c/bubblesort.c} 
% \bigskip\bigskip



\newpage
\subsection{Generación de código del algoritmo \textit{Pgm} en Assembly MIPS32}

	A continuación se presenta el código en Assembly MIPS32 del algoritmo \texit{Pgm} generado automáticamente por el compilador \texit{GCC}. En el Apéndice A se encuentra el código en su totalidad.
	\medskip

% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeBSh,caption=``bubblesort.h'']{../Codigo/c/bubblesort.h} 
% \bigskip


% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeBSc,caption=``bubblesort.c'']{../Codigo/c/bubblesort.c} 
% \bigskip\bigskip


% Debugging
\section{Debugging}
	
	Para analizar el correcto funcionamiento del programa se crearon casos de prueba pertinentes, considerando combinaciones diferentes en el ingreso de parámetros al programa principal, como también tomando en cuenta las diferentes salidas obtenidas a partir del algorirmo pgm. Los resultados fueron comparados con los casos esperados y así se determinó el correcto funcionamiento del programa en su totalidad.
\bigskip




% Pruebas
\section{Pruebas}

	A modo de prueba del programa, se ingresaron ciertos parámetros a éste y se analizó la salida obtenida. A continuación se presentan algunas pruebas realizadas y los resultados obtenidos.
	\par
	El primer caso consiste en crear un tablero de resolución 11x16 y que el resultado sea enviado a salida standard. Se debe ingresar por consola lo siguiente:
	\smallskip

{\ttfamily\footnotesize
\indent \$ ./tp0 -r 11x16 -o -\\}
\smallskip

	La salida del programa es la siguiente:

\begin{center}
P2
# -
11 16
1
1 1 0 0 1 1 0 1 0 1 0 
1 1 0 0 1 1 0 1 0 1 0 
0 0 1 1 0 0 1 0 1 0 1 
0 0 1 1 0 0 1 0 1 0 1 
1 1 0 0 1 1 0 1 0 1 0 
1 1 0 0 1 1 0 1 0 1 0 
0 0 1 1 0 0 1 0 1 0 1 
0 0 1 1 0 0 1 0 1 0 1 
1 1 0 0 1 1 0 1 0 1 0 
1 1 0 0 1 1 0 1 0 1 0 
0 0 1 1 0 0 1 0 1 0 1 
0 0 1 1 0 0 1 0 1 0 1 
1 1 0 0 1 1 0 1 0 1 0 
1 1 0 0 1 1 0 1 0 1 0 
0 0 1 1 0 0 1 0 1 0 1 
0 0 1 1 0 0 1 0 1 0 1 
\end{center}
\bigskip\bigskip

	\par
	La segunda prueba consiste en crear un tablero de resolución 16x11 y también enviar la salida a consola. Se debe ingresar por consola:
	\smallskip

{\ttfamily\footnotesize
\indent \$ ./tp0 -r 16x11 -o -\\}
\smallskip

	La salida del programa es la siguiente:

\begin{center}
P2
# -
16 11
1
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 
1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1  
\end{center}
\bigskip\bigskip

	\par
	La tercer prueba consiste en generar el tablero de tamaño default 8x8 (se genera en caso de no ingresar la opción -r), ingresando por consola:
	\smallskip

{\ttfamily\footnotesize
\indent \$ ./tp0 -o -\\}
\smallskip

	El resultado del programa se ve por salida standard y es el siguiente:

\begin{center}
P2
# -
8 8
1
1 0 1 0 1 0 1 0 
0 1 0 1 0 1 0 1 
1 0 1 0 1 0 1 0 
0 1 0 1 0 1 0 1 
1 0 1 0 1 0 1 0 
0 1 0 1 0 1 0 1 
1 0 1 0 1 0 1 0 
0 1 0 1 0 1 0 1 
\end{center}
\bigskip\bigskip

	\par
	Una prueba más interesante, es aquella en la cual la resolución permite ver una imagen bastante amplia. En este caso se considera una resolución de 200x200 y se decide guardar la salida en un archivo. Se debe ingresar por consola:
	\smallskip

{\ttfamily\footnotesize
\indent \$ ./tp0 -r 200x200 -o 200x200.pgm\\}
\smallskip

	La salida en formato imagen \textit{PGM}, es la siguiente:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.85\textwidth]{images/200x200.pgm}
	\medskip
	\caption{Imágen del tablero de ajedrez en resolución 200x200.}
\end{figure}
\bigskip\bigskip
	






	\par
	A cada ejecución se le midió el tiempo de procesamiento mediante el comando \textit{GNU ``time''} \cite{TIME}. A continuación un ejemplo de su utilización:
\bigskip

{\ttfamily\footnotesize
\indent \$ time ./tp0 -b alice.txt\\}


\noindent Esto imprimirá por pantalla el tiempo de ejecución que fue tabulado para cada caso. En el \textit{Cuadro 1} se muestran los valores de tiempo obtenidos.
\bigskip\bigskip


% Tabla 1
\begin{table}[!hbt]
	\begin{center}
	\begin{tabular}{|>{\centering\arraybackslash}m{3cm}|>{\centering \arraybackslash}m{3cm}|>{\centering \arraybackslash}m{3cm}|>{\centering \arraybackslash}m{3cm}|}
		\hline
		\rowcolor[gray]{0.9}\textbf{Archivo de texto} & \textbf{bubblesort.c [s] } & \textbf{shellsort.c [s] }  & \textbf{shellsort.S [s] }\\
		\hline
		\centering alice.txt & 571,715 & 2,207 & 1,035  \\
		\hline
		\centering beowulf.txt & 958,527 & 3,418 & 1,500  \\
		\hline
		\centering cyclopedia.txt & >3600 \textit{(timeout)} & 12,184 & 6,914   \\
		\hline
		\centering elquijote.txt & >3600 \textit{(timeout)} & 48,957 & 33,098  \\
		\hline
	\end{tabular}
	\caption{Tiempos en segundos obtenidos en la ejecución\\ de los distintos algoritmos.}
	\end{center}
\end{table}
\bigskip\bigskip


	En los graficos que siguen se muestran distintas comparaciones hechas con estos datos obtenidos, los cuales nos llevarán a la conclusión final.
\bigskip\bigskip

% Figura 1
\begin{figure}[h]
	\centering
	\includegraphics[width=0.85\textwidth]{images/imagen01.png}
	\medskip
	\caption{Gráfico de tiempo insumido (en segundos)  contra el\\ tamaño de la muestra (cantidad de palabras)}
\end{figure}

\newpage
% Figura 1
\begin{figure}[h]
	\centering
	\includegraphics[width=0.85\textwidth]{images/imagen02.png}
	\medskip
	\caption{Gráfico del speedup del Bubblesort contra Shellsort\\ para los diversos tamaños de archivo.}
\end{figure}
\bigskip\bigskip


% Conclusiones
\section{Conclusiones}

	Al realizar la comparación entre los algoritmos bubblesort y shellsort en C, vemos que la diferencia entre ambos es notable. Estamos hablando de varios ordenes de maginitud.
	\par
	Esto se debe a que por su codigo bubblesort tiene un coste de O($n^2$) mientras que si bien no podemos determinarlo fácilmente para shellsort, ya que depende mucho del gap elegido, estamos hablando de algo cercano a O($n log(n)$). Esto hace que para textos grandes no sea una opción viable la utilización de bubblesort, mientras que shellsort prueba ser muy eficiente y el esfuerzo de codificación no es demsiado grande.
	\par
	En cuanto a la comparación de assembler y C, notamos una ligera ventaja del primero. Creemos que esto se debe a que muchas de las cosas que el algoritmo en C utiliza como variables en memoria principal, assembler utiliza registros los cuales presentan un tiempo de lecto/escritura notablemente menor.
\bigskip\bigskip




% Citas bibliográficas.
\begin{thebibliography}{99}

	\bibitem{GXEMUL} The NetBSD project, \url{http://www.netbsd.org/}

	\bibitem{GCC} GCC, the GNU Compiler Collection, \url{http://gcc.gnu.org/}

	\bibitem{BS} PGM format speciffication, \url{http://netpbm.sourceforge.net/doc/pgm.html}

	\bibitem{HEN00} J. L. Hennessy and D. A. Patterson, ``Computer Architecture. A Quantitative
	Approach,'' 4th Edition, Morgan Kaufmann Publishers, 2000.

	\end{thebibliography}

\newpage


% Apendices
\begin{appendices}

\bigskip\bigskip

% Implementación completa en lenguaje C
\section{Implementación completa en lenguaje C}


\subsection{\textit{tp0.c}. Implementación del main del programa}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeTP0cfull,caption=``tp0.c'']{../Codigo/c/tp0.c} 
% \bigskip\bigskip

\subsection{\textit{bubblesort.h}. Declaración de la librería Bubblesort}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeBShfull,caption=``bubblesort.h'']{../Codigo/c/bubblesort.h} 
% \bigskip\bigskip

\subsection{\textit{bubblesort.c}. Definición de la librería Bubblesort}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeBScfull,caption=``bubblesort.c'']{../Codigo/c/bubblesort.c} 
% \bigskip\bigskip

\subsection{\textit{shellsort.h}. Declaración de la librería Shellsort}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeSShfull,caption=``shellsort.h'']{../Codigo/c/shellsort.h} 
% \bigskip\bigskip

\subsection{\textit{shellsort.c}. Definición de la librería Shellsort}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeSScfull,caption=``shellsort.c'']{../Codigo/c/shellsort.c} 
% \bigskip\bigskip

\subsection{\textit{fileloader.h}. Declaración de la librería File Loader}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeFLhfull,caption=``fileloader.h'']{../Codigo/c/fileloader.h} 
% \bigskip\bigskip

\subsection{\textit{fileloader.c}. Definición de la librería File Loader}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeFLcfull,caption=``fileloader.c'']{../Codigo/c/fileloader.c} 
% \bigskip\bigskip




% Implementación completa en assembly MIPS
\section{Implementación completa de Shellsort en assembly MIPS}


\subsection{\textit{tp0.c}. Implementación del main del programa}
% % Código
% \lstset{ language = C } % Cambiamos el lenguaje para que parsee en C
% \lstinputlisting[label=codeTP0afull,caption=``tp0.c'']{../Codigo/assembly/tp0.c} 
\bigskip\bigskip

\subsection{\textit{shellsort.S}. Implementación del algoritmo Shellsort}
% % Código
% \lstset{ language = [mips]Assembler} % Cambiamos el lenguaje para que parsee en MIPS
% \lstinputlisting[label=codeSSafull,caption=``shellsort.S'']{../Codigo/assembly/shellsort.S} 
\bigskip\bigskip

\subsection{\textit{compare.S}. Implementación del comparador de palabras}
% % Código
% \lstset{ language = [mips]Assembler} % Cambiamos el lenguaje para que parsee en MIPS
% \lstinputlisting[label=codeCMPafull,caption=``compare.S'']{../Codigo/assembly/compare.S} 
\bigskip\bigskip

\subsection{\textit{swap.S}. Implementación del comparador de palabras}
% % Código
% \lstset{ language = [mips]Assembler} % Cambiamos el lenguaje para que parsee en MIPS
% \lstinputlisting[label=codeSWAPafull,caption=``swap.S'']{../Codigo/assembly/swap.S} 
\bigskip\bigskip


\end{appendices}

\end{document}
